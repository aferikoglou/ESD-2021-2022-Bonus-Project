# Parser Architecture

## Component List
1. Python Preprocessor
1. Libclang frontend analyzer
1. Python workflow manager
1. Autogenerated C++ file
1. Makefile
---
## Brief Description

### Python Preprocessor
Finds lines of code that are ignored in the analysis

### Libclang Frontend analyzer
Identifies Array Declarations, Loops and their locations

### Python workflow manager
Launches all other processes, creates and compiles the C++ Autogenerated File

### Autogenerated C++ file
Calculates loop boundaries and reports them to the main Python file

### Makefile
Compiles the C++ file

---
## Under Development: Static Analysis with LLVM + clang + opt

### Step 1: Generate LLVM IR (DONE)
Compile code to LLVM IR code: Generate an **architecture independent** represantation for the code. Easy by using **clang**

### Step 2: Create A Custom LLVM opt Pass (Under Development)
Opt performs analysis and optimization on LLVM IR Code. Code already exists for counting the total number of instructions in a source file. Functionality in opt is added by creating "Passes".

### Step 3: Profit???

Goal: Create a Pass that counts the number of instruction in each loop and their type

Current Status: Created a Pass that counts the number of instuctions in each Function (not their type).

**Source code and instructions for creating a pass available**

---

## Ideas for the future

If familiarity with opt is acquired we can expect the following:

1. Analyze loops more precisely: Current analysis expects that loops have a "< or <= condition"

1. Analyze more loops: By leveraging opt's **constant propagation, expression elimination and loop normalization** passes more loops can be analyzed

As our knowledge of LLVM increases we can expect to migrate code to it for more precise and powerful analysis. 

---


## Ideal Parser-Analyzer Architecture

- **Frontend**: libclang to identify analysis locations

- **Backend**: LLVM + opt to analyze the locations targeted by libclang




