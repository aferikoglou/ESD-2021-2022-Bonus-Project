import re
import sys
import subprocess

hls_input_file = sys.argv[1]
cpp_autogenerated_file = 'hls_extractor_temp_file.cpp'

libclang_compilation_flags = ["-I/opt/xilinx/xrt/include","-I/tools/Xilinx/Vivado/2021.1/include","-Wall","-O0","-g","-std=c++11","-fmessage-length=0","-L/opt/xilinx/xrt/lib","-I/opt/Xilinx/Vitis_HLS/2020.2/include","-lOpenCL","-pthread","-lrt","-lstdc++"]

p = subprocess.Popen(["python3","preprocessor.py",hls_input_file])
p.wait()

with open("extracted_locs.txt",'w') as outfile:
    p = subprocess.Popen(["./aux_arr",hls_input_file,*libclang_compilation_flags],stdout=outfile)
    p.wait()

file_lines = []
with open(hls_input_file,'r') as f:
    file_lines = f.readlines()

with open("extracted_locs.txt","r") as locs_file:
    locs_lines = locs_file.readlines()

################################ LOOP EXTRACTION ####################

extractor_info = []
array_locs = []
for i in locs_lines:
    tmp = i.split(',')

    line_loc = int(tmp[1])
    col_loc = int(tmp[2])
    global_idx = int(tmp[3])
    
    if tmp[0] == 'A':
        array_locs.append((line_loc,col_loc,global_idx,tmp[4][:-1]))
    elif tmp[0] == 'L':
        extractor_info.append((line_loc,col_loc,global_idx,file_lines[line_loc]))

loop_info = []
for line in extractor_info:
    loop_info.append((line[0],line[1],line[2],re.findall(r'\(.*\)',line[3])))

expression_elimination = []
for expr in loop_info:
    expression_elimination.append((expr[0],expr[1],expr[2],re.findall(r'<.*;',expr[3][0])[0][1:]))
########################### FEATURE EXTRACTION #########################

#print(array_locs)

array_decls = []
for line in array_locs:
    array_decl = re.split(r"[,;]",file_lines[line[0]][line[1]:-1])[0]
    dims = array_decl.count('[')
    expr_split = list(filter(lambda a: a!='',re.split(r"[\[\]]",array_decl)[1:]))
    array_decls.append((line[0],line[1],line[2],line[3],dims,*expr_split))

'''
for i in extractor_info:
    print(f"{i}")
print("===========================================")
for i in array_decls:
    print(f"{i}")

'''

########################## SIM FILE GENERATION ######################

with open(cpp_autogenerated_file,'w') as cpp_file:
    cpp_file.write(f"#include \"{hls_input_file}\"\n")
    cpp_file.write(f"#include <iostream>\n")
    cpp_file.write(f"using namespace std;\n\n")


    for for_expr in expression_elimination:
        cpp_file.write(f"#define L{for_expr[0]} {for_expr[3][:-1]}\n")

    for decl in array_decls:
        for i in range(decl[4]):
            cpp_file.write(f"#define A_{decl[3]}_{i} {decl[5+i]}\n")

    cpp_file.write("int main(){\n")
    
    for for_expr in expression_elimination:
        cpp_file.write(f"cout << \"L_{for_expr[0]}\" << \":\"<< L{for_expr[0]} << endl;\n")

    for decl in array_decls:
        for i in range(decl[4]):
            cpp_file.write(f"cout << \"A_{decl[3]}_{i}\" << ':' << A_{decl[3]}_{i} << endl;\n")

    cpp_file.write("return 0;\n}")

##################### SIM FILE EXEC #############################

p = subprocess.Popen(['make'])
p.wait()

with open("extractor_output_file.out",'w') as outfile:
    p = subprocess.Popen(['./autogen_exit'],stdout=outfile)
p.wait()

parser_lines = []
with open("extractor_output_file.out",'r') as infile:
    parser_lines = infile.readlines()

arrays_aux = dict()
arrays = dict()
loops = dict()

################# EXTRACTED INFO ###############

for line in parser_lines:
    split_line = line.split(':')
    if line[0] == 'L':
        loops[split_line[0][2:]] = int(split_line[1])
    elif line[0] == 'A':
        arrays_aux[split_line[0][2:]] = int(split_line[1])

for decl in array_decls:
    temp = []
    for i in range(decl[4]):
        temp.append(arrays_aux[f"{decl[3]}_{i}"])
    arrays[decl[3]] = list(temp)


for i in loops:
    print(f"{i}, {loops[i]}")
print("------------------")
for i in arrays:
    print(f"{i}, {arrays[i]}")

### DONE

###################### TAG INPUT FILE #####################
for L in expression_elimination:
    file_lines[L[0]] = f"L{L[2]}:"+file_lines[L[0]]

for L in array_decls:
    file_lines[L[0]] = f"L{L[2]}:"+file_lines[L[0]]


##################### STRIP ORIGINAL DIRECTIVES########################
enable_strip = 1

new_file_lines = []
if enable_strip > 0:

    for line in file_lines:
        if "#pragma" not in line: #pragma detected
            new_file_lines.append(line)
        else:
            if re.search(r'\barray_partition\b',line,flags=re.IGNORECASE)==None and re.search(r'\bpipeline\b',line,flags=re.IGNORECASE)==None and re.search(r'\bunroll\b',line,flags=re.IGNORECASE)==None:
                new_file_lines.append(line)

    with open(hls_input_file,'w') as outfile:
        outfile.writelines(new_file_lines)

######################## GENERATE KERNEL_INFO.TXT ###########################
kernel_name = input("Set HLS kernel name:")

with open("kernel_info.txt",'w') as outfile:
    outfile.write(f"{kernel_name}\n")


    total_rng = len(array_decls) + len(extractor_info)
    for index in range(total_rng):
        for array in array_decls:
            if (index+1 == array[2]):
                array_str = f"L{array[2]},array,{array[3]}"
                for i in range(1,array[4]+1):
                    array_str += ',' + str(i) + ',' + str(arrays[array[3]][i-1])
                array_str += "\n"
                outfile.write(array_str)


        for loop in extractor_info:
            if (index+1 == loop[2]):
                loop_str = f"L{loop[2]},loop," + str(loops[f"{loop[0]}"]) + "\n"
                outfile.write(loop_str)

with open("hls_loop_ranges.txt",'w') as hls_ranges:
    p = subprocess.Popen(["./loop_an_source",hls_input_file,*libclang_compilation_flags],stdout=hls_ranges)
p.wait()

p = subprocess.Popen(["python3","loop_analyzer.py","hls_loop_ranges.txt"])
p.wait()
