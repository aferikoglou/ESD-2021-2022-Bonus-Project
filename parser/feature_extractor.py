import re
import sys
import subprocess
import json
import modules.preprocessor as preprocessor
import modules.loop_analyzer as loop_analyzer
import os

HLS_INPUT_FILE = sys.argv[1]
HLS_INPUT_DIRECTORY = os.path.dirname(HLS_INPUT_FILE)
LOOP_STRUCTURE_JSON = f"{HLS_INPUT_DIRECTORY}/loop_structure.json"
KERNEL_INFO = f"{HLS_INPUT_DIRECTORY}/kernel_info.txt"
CPP_AUTOGENERATED_FILE = 'hls_extractor_temp_file.cpp'
KERNEL_INFO_PRECURSOR = "hls_extracted_locs.txt"
LOOP_RANGES_FILE = "hls_loop_ranges.txt"
HLS_EXCLUSION_FILE = "hls_exclusion_list.txt"
EXTRACTOR_OUTPUT_FILE = "extractor_output_file.out"

LIBCLANG_COMPILATION_FLAGS = ["-I/opt/xilinx/xrt/include","-I/tools/Xilinx/Vivado/2021.1/include","-Wall","-O0","-g","-std=c++11","-fmessage-length=0","-L/opt/xilinx/xrt/lib","-I/opt/Xilinx/Vitis_HLS/2020.2/include","-lOpenCL","-pthread","-lrt","-lstdc++"]

DELETION_LIST = ["autogen_exit",LOOP_RANGES_FILE,CPP_AUTOGENERATED_FILE,KERNEL_INFO_PRECURSOR,HLS_EXCLUSION_FILE,EXTRACTOR_OUTPUT_FILE]

preprocessor.generate_exclusion_list(HLS_INPUT_FILE,HLS_EXCLUSION_FILE)

p = subprocess.Popen(["./an_source",HLS_INPUT_FILE,*LIBCLANG_COMPILATION_FLAGS])
p.wait()

loop_analysis_list = loop_analyzer.loop_analysis(LOOP_RANGES_FILE)
with open(LOOP_STRUCTURE_JSON,"w") as lsj:
    json.dump(loop_analysis_list,lsj)

file_lines = []
with open(HLS_INPUT_FILE,'r') as f:
    file_lines = f.readlines()

with open(KERNEL_INFO_PRECURSOR,"r") as locs_file:
    locs_lines = locs_file.readlines()

################################ LOOP EXTRACTION ####################

extractor_info = []
array_locs = []
for i in locs_lines:
    tmp = i.split(',')

    line_loc = int(tmp[1])
    col_loc = int(tmp[2])
    global_idx = int(tmp[3])
    
    if tmp[0] == 'A':
        array_locs.append((line_loc,col_loc,global_idx,tmp[4][:-1]))
    elif tmp[0] == 'L':
        extractor_info.append((line_loc,col_loc,global_idx,file_lines[line_loc]))

loop_info = []
for line in extractor_info:
    loop_info.append((line[0],line[1],line[2],re.findall(r'\(.*\)',line[3])))

expression_elimination = []
for expr in loop_info:
    expression_elimination.append((expr[0],expr[1],expr[2],re.findall(r'<.*;',expr[3][0])[0][1:]))
    
########################### FEATURE EXTRACTION #########################

#print(array_locs)

array_decls = []
for line in array_locs:
    array_decl = re.split(r"[,;]",file_lines[line[0]][line[1]:-1])[0]
    dims = array_decl.count('[')
    expr_split = list(filter(lambda a: a!='',re.split(r"[\[\]]",array_decl)[1:]))
    array_decls.append((line[0],line[1],line[2],line[3],dims,*expr_split))


########################## SIM FILE GENERATION ######################

with open(CPP_AUTOGENERATED_FILE,'w') as cpp_file:
    cpp_file.write(f"#include \"{HLS_INPUT_FILE}\"\n")
    cpp_file.write(f"#include <iostream>\n")
    cpp_file.write(f"using namespace std;\n\n")


    for for_expr in expression_elimination:
        cpp_file.write(f"#define L{for_expr[0]} {for_expr[3][:-1]}\n")

    for decl in array_decls:
        for i in range(decl[4]):
            cpp_file.write(f"#define A_{decl[3]}_{i} {decl[5+i]}\n")

    cpp_file.write("int main(){\n")
    
    for for_expr in expression_elimination:
        cpp_file.write(f"cout << \"L_{for_expr[0]}\" << \":\"<< L{for_expr[0]} << endl;\n")

    for decl in array_decls:
        for i in range(decl[4]):
            cpp_file.write(f"cout << \"A_{decl[3]}_{i}\" << ':' << A_{decl[3]}_{i} << endl;\n")

    cpp_file.write("return 0;\n}")

##################### SIM FILE EXEC #############################

p = subprocess.Popen(['make'])
p.wait()

with open(EXTRACTOR_OUTPUT_FILE,'w') as outfile:
    p = subprocess.Popen(['./autogen_exit'],stdout=outfile)
p.wait()

parser_lines = []
with open(EXTRACTOR_OUTPUT_FILE,'r') as infile:
    parser_lines = infile.readlines()

arrays_aux = dict()
arrays = dict()
loops = dict()

################# EXTRACTED INFO ###############

for line in parser_lines:
    split_line = line.split(':')
    if line[0] == 'L':
        loops[split_line[0][2:]] = int(split_line[1])
    elif line[0] == 'A':
        arrays_aux[split_line[0][2:]] = int(split_line[1])

for decl in array_decls:
    temp = []
    for i in range(decl[4]):
        temp.append(arrays_aux[f"{decl[3]}_{i}"])
    arrays[decl[3]] = list(temp)


for i in loops:
    print(f"{i}, {loops[i]}")
print("------------------")
for i in arrays:
    print(f"{i}, {arrays[i]}")

### DONE

###################### TAG INPUT FILE #####################
for L in expression_elimination:
    file_lines[L[0]] = f"L{L[2]}:"+file_lines[L[0]]

for L in array_decls:
    file_lines[L[0]] = f"L{L[2]}:"+file_lines[L[0]]


##################### STRIP ORIGINAL DIRECTIVES########################
enable_strip = 1

new_file_lines = []
if enable_strip > 0:

    for line in file_lines:
        if "#pragma" not in line: #pragma detected
            new_file_lines.append(line)
        else:
            if re.search(r'\barray_partition\b',line,flags=re.IGNORECASE)==None and re.search(r'\bpipeline\b',line,flags=re.IGNORECASE)==None and re.search(r'\bunroll\b',line,flags=re.IGNORECASE)==None:
                new_file_lines.append(line)

    with open(HLS_INPUT_FILE,'w') as outfile:
        outfile.writelines(new_file_lines)

######################## GENERATE KERNEL_INFO.TXT ###########################
kernel_name = input("Set HLS kernel name:")

with open(KERNEL_INFO,'w') as outfile:
    outfile.write(f"{kernel_name}\n")


    total_rng = len(array_decls) + len(extractor_info)
    for index in range(total_rng):
        for array in array_decls:
            if (index+1 == array[2]):
                array_str = f"L{array[2]},array,{array[3]}"
                for i in range(1,array[4]+1):
                    array_str += ',' + str(i) + ',' + str(arrays[array[3]][i-1])
                array_str += "\n"
                outfile.write(array_str)


        for loop in extractor_info:
            if (index+1 == loop[2]):
                loop_str = f"L{loop[2]},loop," + str(loops[f"{loop[0]}"]) + "\n"
                outfile.write(loop_str)

##### CLEANUP TEMP FILES
p = subprocess.Popen(["rm","-f",*DELETION_LIST])
p.wait()


